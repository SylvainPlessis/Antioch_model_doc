\subsection{The physical object}

A chemical reaction is represented like
\begin{chemicalEquation}
\ce{A ->[\text{conditions}][\rate] B}
\end{chemicalEquation}
\ce{A} and \ce{B} being any kind of molecular composition
related through the reaction. The conditions are usually
simply the temperature. The rate depends on the kinetics
model and the thermodynamics of the entities \ce{A} and
\ce{B}. So basically, we have three types of data:
\begin{itemize}
\item the rate parameters needed to characterize \rate: 
                \fwdratecons, the thermodynamics;
\item the reaction's conditions: usually temperature, but can
        be also particles flux, some catalysis data, \dots;
\item the densities of the molecular medium (namely \ce{A}
        and \ce{B}).
\end{itemize}


Figure~\ref{kinpf} describe the data flow from the upper
object \KineticsEvaluator\ to the rate constants objects.
The idea here is to have a light high-level object that will
be fast to build, so easily threadable. All the necessary data
and the bulk of the work is in lower-level objects.
%
\begin{figure}
\centering
\includegraphics[width=\linewidth]{kinetics_relationships}
\caption{\label{kinpf}Global vision of the kinetics in \Antioch.
The gray area frames objects that should not be threaded, whereas
\KineticsEvaluator\ is light and thread-safe. The passed values of
interest are the temperature \prog{const StateType \& T}, the
particle flux \prog{const ParticleFlux<VectorCoeffType> \& pf} and
the composition \prog{const VectorStateType \& dens}.}
\end{figure}
%
\subsection{A classical case}

Let's consider a simple bimolecular reaction, elementary,
with a Kooij kinetics model. The informations we need for
a complete kinetics calculation are the temperature, the
composition and the thermodynamics. The thermodynamics are
calculated in another place of the program, what \Antioch\
will provide will be the Gibbs energy for all the concerned
species (see section~\ref{kinetics_gen}, \textbf{Going backward}
subsection). So at the \KineticsEvaluator\ level, we need
to provide \Antioch's guts with:
\begin{itemize}
\item a \prog{const StateType \& T} for the temperature,
\item a \prog{const VectorStateType \& molar\_densities} for
                the densities,
\item a \prog{const VectorStateType \& h\_RT\_minus\_s\_R} for
                the thermodynamics.
\end{itemize}

The goal is to have the quantity \doverdt{S} for all species \ce{S} concerned by the 
reactive system (see \ref{phys:kinetics_theory_integrated}).

\subsubsection{Data flow}

\paragraph{\KineticsEvaluator}
will gain from \ReactionSet\ the net rates of
the reactions,  i.e. the term \rate[r] in \ref{phys:kinetics_theory_integrated}.
Thus \KineticsEvaluator\ will, for every species, perform the loop
over the concerned reactions and multiply by the stoichiometric coefficient.
Technically, \KineticsEvaluator\ gives \ReactionSet\ a \prog{VectorCoeffType}
to fill with these terms.

\paragraph{\ReactionSet}
will equate the values of the provided \prog{VectorCoeffType} with
the returning value given by the \Reaction. To do that, it passes down to
the \Reaction\ object the temperature, the composition, the thermodynamics and
the value $\frac{\pz}{\Rg \Temp}$, used for the equilibrium constant calculation,
needed for the backward rate constant \eqref{therm:K_therm}.

\paragraph{\Reaction} will asks the \KineticsType\ object (its rate constants) to calculate
the forward rate constant of the reaction (term \fwdratecons[r]) by passing
it the temperature. Then it will be able 
to calculate the backward rate constant (term \bkwdratecons[r]), 
the forward (term \fwdrate[r]) and backward rate (term \bkwdrate[r]), 
and finally the net rate (term \rate[r]).

\paragraph{\KineticsType} will return the forward rate constant \fwdratecons[r] given
the temperature.

\subsubsection{Template flow}

\paragraph{\KineticsEvaluator} asks for a \prog{VectorCoeffType} to be filled. It
provides a \prog{StateType} for the temperature and a \prog{VectorStateType} for
the densities.

\paragraph{\ReactionSet} fills each value of the \prog{VectorCoeffType} with
the returning type of \Reaction.

\paragraph{\Reaction} returns a \prog{StateType}, which is the defined type of the
provided temperature.

\paragraph{\KineticsType} returns a \prog{StateType}, defined by the type of the
provided temperature.

\subsection{A particle flux reaction}

A reaction occuring with a particle flux is another type of reaction than the one
previously considered. Basically, instead of having molecules bumping into each
other and joyfully transforming into other molecules, this kind of reaction is
a molecule shot by particles, and transforming into another molecule(s). A simple
example is photoinduced ionization, a photon will hit a molecule, be absorbed, and
the excedental energy will pop out an electron, thus describing the reaction
\ce{A ->[\mathrm{h}\nu] A+}. In the classical view, this means that the rate constant
is constant, as it does not depend on the temperature. \Antioch\ supports at this
moment only photochemical reaction, but what will be describe here holds for any
particle flux-induced reaction.

The only change so is that instead of passing down a temperature,
we need to pass down a particle flux (\ParticleFlux) along the path
\KineticsEvaluator, \ReactionSet\ and \Reaction.
The big difference is the type of the data. A temperature is an atomic type (typically
a \prog{double} or a \prog{float}, while the \ParticleFlux\ is a \ParticleFlux, and
contains a vector type (the full description is \ParticleFlux\prog{<VectorCoeffType>}),
as is needs to store a flux intensity and a grid (wavelength, energy, \dots) corresponding
to those intensity. A photon flux will be characterized by an intensity per wavelength.

Thus the program flow stays the same, just replace the temperature with the particle
flux. Where it gets tricky is at the \Reaction\ level, where it returns the net reaction
rate value. Two things to consider here: a reaction occuring through particle flux
chemistry is irreversible in nature, so no backward rate consideration (nor thermodynamics),
we need to extract a \prog{StateType} out of a \ParticleFlux\prog{<VectorCoeffType>}.
The concerned method is (templates left out)
\begin{center}
\verb!StateType Reaction::compute_rate_of_progress() const!
\end{center}
with \prog{StateType} provided by the passed temperature. In this case however, we but
need the molecular densities (\prog{VectorStateType}) and the \ParticleFlux. So the
question is, how do we get the \prog{StateType} type?

Several possibilities here:
\begin{enumerate}
\item\label{type_pass} we pass down the temperature anyway, just for the type;
\item\label{meta_paradise} heck man, meta computing is so great, let's just refactore those method!
\end{enumerate}

The method \ref{type_pass} is simple, we would need to overload the methods:
\begin{verbatim}
  template<typename CoeffType, typename VectorCoeffType>
  template <typename StateType, typename VectorStateType>
  inline
  StateType Reaction<CoeffType,VectorCoeffType>::compute_rate_of_progress( 
                const VectorStateType& molar_densities,
                const StateType& T,  
                const StateType& P0_RT,  
                const VectorStateType& h_RT_minus_s_R) const;
\end{verbatim}
with
\begin{verbatim}
  template<typename CoeffType, typename VectorCoeffType>
  template <typename StateType, typename VectorStateType>
  inline
  StateType Reaction<CoeffType,VectorCoeffType>::compute_rate_of_progress( 
                const VectorStateType& molar_densities,
                const ParticleFlux<VectorStateType>& pf,
                const StateType & /*T*/) const;
                
\end{verbatim}
and so forth down to \KineticsType.

Method \ref{meta_paradise} would require a little bit more perversion, but not
too much overloading. Basically the idea would be to have the definition
\begin{verbatim}
  template<typename CoeffType, typename VectorCoeffType>
  template <typename DataType, typename VectorStateType, typename StateType>
  inline
  typedef typename Antioch::atomic_type<DataType>::type
        Reaction<CoeffType,VectorCoeffType>::compute_rate_of_progress( 
                const VectorStateType& molar_densities,
                const DataType& T,  
                const StateType& P0_RT,  
                const VectorStateType& h_RT_minus_s_R) const;
\end{verbatim}
with the meta function
\begin{verbatim}
  template <typename T, typename Enable=void>
  struct atomic_type;
\end{verbatim}
that would be defined as
\begin{verbatim}
template <typename T>
struct atomic_type<T>
{
  typedef T type;
};
\end{verbatim}
for all there is (eigen, metaphysicl, valarray, vector, vexcl, ANTIOCH\_PLAIN\_SCALAR), and
as
\begin{verbatim}
template <typename T>
struct atomic_type<ParticleFlux<T> >
{
  typedef typename Antioch::value_type<T>::type type;
};
\end{verbatim}
for the particle flux.

We have templates for the data, basically temperature, molar
densities, thermodynamics and particle flux. In all these, temperature
and particle flux are equivalent because they are directly associated
to the calculations of the forward rate constant at the lowest level. 
Thus, at the \KineticsType\ level, we have basically the method:
\begin{verbatim}
template <typename StateType>
StateType rate(const StateType &T);
\end{verbatim}
We generalize it by:
\begin{verbatim}
template <typename StateType, typename DataType>
StateType rate(const DataType &T);
\end{verbatim}
The \prog{DataType} being either a temperature or a particle flux (or anything we
cannot think of right now). So what to do?

The idea is to define an \prog{atomic\_type}, which is the type of the temperature.
The data cannot be simpler than that. So we have data in a type that is either
atomic or composed. A particle flux is basically two vectors of atomic data, thus:
\begin{verbatim}
template <typename DataType>
typename atomic_type<DataType>::type rate(const DataType &T);
\end{verbatim}
Another thing pops out. In the calculations, we can use either the data in its atomic
or composed form. Thus a kinetics model should use only the type it needs:
\begin{verbatim}
template <typename DataType>
typename atomic_type<DataType>::type 
        rate(const typename atomic_type<DataType>::type &
                            atomic_value<DataType>(T));
\end{verbatim}
for a temperature, and 
\begin{verbatim}
template <typename DataType>
typename atomic_type<DataType>::type 
        rate(const typename particle_flux_type<DataType>::type &
                            particle_value<DataType>(T));
\end{verbatim}
for a particle flux.

Thus a new composed data requires:
\begin{itemize}
\item a meta-macro \verb!atomic_type!  to gain the atomic type from it;
\item a meta-macro \verb!atomic_value! to gain the atomic value from it;
\item a meta-macro \verb!new_data_type! to gain the composed data type;
\item a meta-macro \verb!new_data_value! to gain the composed data value.
\end{itemize}
Some more are needed:
\begin{itemize}
\item \verb!zero_clone! to atomic type;
\item \verb!constant_clone! to atomic type.
\end{itemize}
other clones are not needed.
