Figure~\ref{kinpf} describe the data flow from the upper
object \KineticsEvaluator\ to the rate constants objects.
The idea here is to have a light high-level object that will
be fast to build, so easily threadable. All the necessary data
and the bulk of the work is in lower-level objects.
%
\begin{figure}
\centering
\includegraphics{kinetics_relationships}
\caption{\label{kinpf}Global vision of the kinetics in \Antioch.
The gray area frames objects that should not be threaded, whereas
\KineticsEvaluator\ is light and thread-safe. The passed values of
interest are the temperature \prog{const StateType \& T}, the
particle flux \prog{const ParticleFlux<VectorCoeffType> \& pf} and
the composition \prog{const VectorStateType \& dens}.}
\end{figure}
%
\subsection{A classical case}

Let's consider a simple bimolecular reaction, elementary,
with a Kooij kinetics model. The informations we need for
a complete kinetics calculation are the temperature, the
composition and the thermodynamics. The thermodynamics are
calculated in another place of the program, what \Antioch\
will provide will be the Gibbs energy for all the concerned
species (see section~\ref{kinetics_gen}, \textbf{Going backward}
subsection). So at the \KineticsEvaluator\ level, we need
to provide \Antioch's guts with:
\begin{itemize}
\item a \prog{const StateType \& T} for the temperature,
\item a \prog{const VectorStateType \& molar\_densities} for
                the densities,
\item a \prog{const VectorStateType \& h\_RT\_minus\_s\_R} for
                the thermodynamics.
\end{itemize}

The goal is to have the quantity \doverdt{S} for all species \ce{S} concerned by the 
reactive system (see \ref{phys:kinetics_theory_integrated}).

\subsubsection{Data flow}

\paragraph{\KineticsEvaluator}
will gain from \ReactionSet\ the net rates of
the reactions,  i.e. the term \rate[r] in \ref{phys:kinetics_theory_integrated}.
Thus \KineticsEvaluator\ will, for every species, perform the loop
over the concerned reactions and multiply by the stoichiometric coefficient.
Technically, \KineticsEvaluator\ gives \ReactionSet\ a \prog{VectorCoeffType}
to fill with these terms.

\paragraph{\ReactionSet}
will equate the values of the provided \prog{VectorCoeffType} with
the returning value given by the \Reaction. To do that, it passes down to
the \Reaction\ object the temperature, the composition, the thermodynamics and
the value $\frac{\pz}{\Rg \Temp}$, used for the equilibrium constant calculation,
needed for the backward rate constant \eqref{therm:K_therm}.

\paragraph{\Reaction} will asks the \KineticsType\ object (its rate constants) to calculate
the forward rate constant of the reaction (term \fwdratecons[r]) by passing
it the temperature. Then it will be able 
to calculate the backward rate constant (term \bkwdratecons[r]), 
the forward (term \fwdrate[r]) and backward rate (term \bkwdrate[r]), 
and finally the net rate (term \rate[r]).

\paragraph{\KineticsType} will return the forward rate constant \fwdratecons[r] given
the temperature.

\subsubsection{Template flow}

\paragraph{\KineticsEvaluator} asks for a \prog{VectorCoeffType} to be filled. It
provides a \prog{StateType} for the temperature and a \prog{VectorStateType} for
the densities.

\paragraph{\ReactionSet} fills each value of the \prog{VectorCoeffType} with
the returning type of \Reaction.

\paragraph{\Reaction} returns a \prog{StateType}, which is the defined type of the
provided temperature.

\paragraph{\KineticsType} returns a \prog{StateType}, defined by the type of the
provided temperature.

\subsection{A particle flux reaction}

A reaction occuring with a particle flux is another type of reaction than the one
previously considered. Basically, instead of having molecules bumping into each
other and joyfully transforming into other molecules, this kind of reaction is
a molecule shot by particles, and transforming into another molecule(s). A simple
example is photoinduced ionization, a photon will hit a molecule, be absorbed, and
the excedental energy will pop out an electron, thus describing the reaction
\ce{A ->[\mathrm{h}\nu] A+}. In the classical view, this means that the rate constant
is constant, as it does not depend on the temperature. \Antioch\ supports at this
moment only photochemical reaction, but what will be describe here holds for any
particle flux-induced reaction.

The only change so is that instead of passing down a temperature, \KineticsEvaluator,
\ReactionSet\ and \Reaction\ need to pass down a particle flux (\ParticleFlux). The
big difference is the type of the data. A temperature is an atomic type (typically
a \prog{double} or a \prog{float}, while the \ParticleFlux\ is a \ParticleFlux, and
contains a vector type (the full description is \ParticleFlux\prog{<VectorCoeffType>}),
as is needs to store a flux intensity and a grid (wavelength, energy, \dots) corresponding
to those intensity. A photon flux will be characterized by an intensity per wavelength.

Thus the program flow stays the same, just replace the temperature with the particle
flux. Where it gets tricky is at the \Reaction\ level, where it returns the net reaction
rate value. Two things to consider here: a reaction occuring through particle flux
chemistry is irreversible in nature, so no backward rate consideration (nor thermodynamics),
we need to extract a \prog{StateType} out of a \ParticleFlux\prog{<VectorCoeffType>}.
The concerned method is (templates left out)
\begin{center}
\verb!StateType Reaction::compute_rate_of_progress() const!
\end{center}
with \prog{StateType} provided by the passed temperature. In this case however, we but
need the molecular densities (\prog{VectorStateType}) and the \ParticleFlux. So the
question is, how do we get the \prog{StateType} type?

Several possibilities here:
\begin{enumerate}
\item\label{type_pass} we pass down the temperature anyway, just for the type;
\item\label{meta_paradise} heck man, meta computing is so great, let's just refactore those method!
\end{enumerate}

The method \ref{type_pass} is simple, we would need to overload the methods:
\begin{verbatim}
  template<typename CoeffType, typename VectorCoeffType>
  template <typename StateType, typename VectorStateType>
  inline
  StateType Reaction<CoeffType,VectorCoeffType>::compute_rate_of_progress( 
                const VectorStateType& molar_densities,
                const StateType& T,  
                const StateType& P0_RT,  
                const VectorStateType& h_RT_minus_s_R) const;
\end{verbatim}
with
\begin{verbatim}
  template<typename CoeffType, typename VectorCoeffType>
  template <typename StateType, typename VectorStateType>
  inline
  StateType Reaction<CoeffType,VectorCoeffType>::compute_rate_of_progress( 
                const VectorStateType& molar_densities,
                const ParticleFlux<VectorStateType>& pf,
                const StateType & /*T*/) const;
                
\end{verbatim}
and so forth down to \KineticsType.

Method \ref{meta_paradise} would require a little bit more perversion, but no
overloading. Basically the idea would be to have the definition
\begin{verbatim}
  template<typename CoeffType, typename VectorCoeffType>
  template <typename DataType, typename VectorStateType, typename StateType>
  inline
  typedef typename Antioch::returned_type<DataType>::type
        Reaction<CoeffType,VectorCoeffType>::compute_rate_of_progress( 
                const VectorStateType& molar_densities,
                const DataType& T,  
                const StateType& P0_RT,  
                const VectorStateType& h_RT_minus_s_R) const;
\end{verbatim}
with the meta function
\begin{verbatim}
  template <typename T, typename Enable=void>
  struct returned_type;
\end{verbatim}
that would be defined as
\begin{verbatim}
template <typename T>
struct returned_type<T>
{
  typedef T type;
};
\end{verbatim}
for all there is (eigen, metaphysicl, valarray, vector, vexcl, ANTIOCH\_PLAIN\_SCALAR), and
as
\begin{verbatim}
template <typename T>
struct returned_type<ParticleFlux<T> >
{
  typedef typename Antioch::value_type<T>::type type;
};
\end{verbatim}
for the particle flux.
